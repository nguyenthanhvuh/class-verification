{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"previous/reading19-2/","title":"Reading19 2","text":"<ul> <li>CSCE990 (Spring 2019): Software Verification - READING LIST<ul> <li>Topic 1: Intro</li> <li>Topic 2: Model Checking</li> <li>Topic 3: Abstraction / Static Analysis</li> <li>Topic 4: Symbolic Execution/Test Case Generation</li> <li>Topic 5: Dynamic analysis, Invariant Generation</li> <li>Topic 6: Automated Debugging</li> <li>Topic 7: Program Repair</li> <li>Topic 8: Program Synthesis</li> <li>Topic 9: Logics/SAT Solving</li> <li>Additional Resources:</li> </ul> </li> </ul>"},{"location":"previous/reading19-2/#csce990-spring-2019-software-verification-reading-list","title":"CSCE990 (Spring 2019): Software Verification - READING LIST","text":""},{"location":"previous/reading19-2/#topic-1-intro","title":"Topic 1: Intro","text":"<ol> <li>William G. Griswold, How to Read an Engineering Research Paper</li> <li>Mike Hicks, Advice on Reviewing Papers</li> <li>Hoare, Axiomatic Basis for Computer Programming. CACM 1969.</li> </ol> <p>Note: You might want to start by with the Hoare logic article from Wikipedia.</p>"},{"location":"previous/reading19-2/#topic-2-model-checking","title":"Topic 2: Model Checking","text":"<ol> <li>JHala et al., Software Model Checking.  ACM Computing Surveys, 2009 Chapter 1</li> <li> <p>JHala et al., Software Model Checking. ACM Computing Surveys, 2009 Chapters 2,3</p> </li> <li> <p>OPTIONAL Visser et al., Model Checking Programs. ASE 2003</p> </li> </ol>"},{"location":"previous/reading19-2/#topic-3-abstraction-static-analysis","title":"Topic 3: Abstraction / Static Analysis","text":"<ol> <li>JHala et al., Software Model Checking. ACM Computing Surveys, 2009 Chapters 4 1. JHala et al., Software Model Checking. ACM Computing Surveys, 2009 Chapters 5 1. Ball et al., Automatic predicate abstraction of C programs. PLDI, 2001 1. Mike Hick's post on Soundness of Static Analysis</li> </ol>"},{"location":"previous/reading19-2/#topic-4-symbolic-executiontest-case-generation","title":"Topic 4: Symbolic Execution/Test Case Generation","text":"<ol> <li>Baldoni et al., A Survey of Symbolic Execution Techniques. CSUR, 2018.</li> </ol> <p>Tool: Java Symbolic PathFinder (SE for Java), KLEE (SE for C)</p>"},{"location":"previous/reading19-2/#topic-5-dynamic-analysis-invariant-generation","title":"Topic 5: Dynamic analysis, Invariant Generation","text":"<ol> <li>Ernst et al., Dynamically Discovering Likely Program Invariants to Support Program Evolution. IEEE Trans. Software Eng 2001.</li> <li>Nguyen et al., SymInfer: Inferring Program Invariants using Symbolic States. ASE 2017.</li> <li>Garg et al., Learning invariants using decision trees and implication counterexamples. POPL 2016.</li> </ol> <p>Tool: Daikon, SymInfer</p>"},{"location":"previous/reading19-2/#topic-6-automated-debugging","title":"Topic 6: Automated Debugging","text":"<ol> <li>Andreas Zeller, Yesterday, My Program Worked. Today, It Does Not. Why?. FSE 1999.</li> <li>James A. Jones et al., Visualization of test information to assist fault localization. ICSE 2002.</li> <li>Bessey et al., A Few Billion Lines of Code Later: Using Static Analysis to Find Bugs in the Real World. CACM</li> </ol> <p>Tool: delta debugging</p>"},{"location":"previous/reading19-2/#topic-7-program-repair","title":"Topic 7: Program Repair","text":"<ol> <li>Weimer et al., Automatically finding patches using genetic programming. ICSE 2009</li> <li>Facebook's automatic bug fixing</li> <li>Introductory program repair  or Angelix ? </li> </ol> <p>Tool: GenProg</p>"},{"location":"previous/reading19-2/#topic-8-program-synthesis","title":"Topic 8: Program Synthesis","text":"<ol> <li>Gulwani et al., Program Synthesis, CSUR</li> </ol> <p>Tool: Sketch</p>"},{"location":"previous/reading19-2/#topic-9-logicssat-solving","title":"Topic 9: Logics/SAT Solving","text":"<ul> <li>Propositional calculus</li> <li>Conflict Driven Clause Learning</li> <li>First-Order Logic</li> <li>SMT Solver</li> </ul> <p>Tool: Z3</p>"},{"location":"previous/reading19-2/#additional-resources","title":"Additional Resources:","text":"<ul> <li>Basic stuff: control flow graph, live/reach defs: https://www.cs.odu.edu/~zeil/cs350/f18/Public/analysis/index.html</li> <li>Build System: https://www.cs.odu.edu/~zeil/cs350/f18/Public/make/index.html</li> <li>Call graphs etc: http://web.cs.iastate.edu/~weile/cs513x/4.ControlFlowAnalysis.pdf</li> <li>Dependency Graph/Slicing: http://web.cs.iastate.edu/~weile/cs513x/5.DependencySlicing.pdf</li> </ul>"},{"location":"previous/reading19/","title":"Reading19","text":"<p>[[TOC]]</p>"},{"location":"previous/reading19/#csce990-spring-2019-software-verification-reading-list","title":"CSCE990 (Spring 2019): Software Verification - READING LIST","text":""},{"location":"previous/reading19/#topic-1-intro","title":"Topic 1: Intro","text":"<ol> <li>William G. Griswold, How to Read an Engineering Research Paper</li> <li>Mike Hicks, Advice on Reviewing Papers</li> <li>Hoare, Axiomatic Basis for Computer Programming. CACM 1969.</li> </ol> <p>Note: You might want to start by with the Hoare logic article from Wikipedia.</p>"},{"location":"previous/reading19/#topic-2-model-checking","title":"Topic 2: Model Checking","text":"<ol> <li>JHala et al., Software Model Checking.  ACM Computing Surveys, 2009 Chapter 1</li> <li> <p>JHala et al., Software Model Checking. ACM Computing Surveys, 2009 Chapters 2,3</p> </li> <li> <p>OPTIONAL Visser et al., Model Checking Programs. ASE 2003</p> </li> </ol>"},{"location":"previous/reading19/#topic-3-abstraction-static-analysis","title":"Topic 3: Abstraction / Static Analysis","text":"<ol> <li>JHala et al., Software Model Checking. ACM Computing Surveys, 2009 Chapters 4 </li> <li>JHala et al., Software Model Checking. ACM Computing Surveys, 2009 Chapters 5</li> <li>Ball et al., Automatic predicate abstraction of C programs. PLDI, 2001</li> <li>Mike Hick's post on Soundness of Static Analysis</li> </ol>"},{"location":"previous/reading19/#topic-4-symbolic-executiontest-case-generation","title":"Topic 4: Symbolic Execution/Test Case Generation","text":"<ol> <li>Baldoni et al., A Survey of Symbolic Execution Techniques. CSUR, 2018.</li> </ol> <p>Tool: Java Symbolic PathFinder (SE for Java), KLEE (SE for C)</p>"},{"location":"previous/reading19/#topic-5-dynamic-analysis-invariant-generation","title":"Topic 5: Dynamic analysis, Invariant Generation","text":"<ol> <li>Ernst et al., Daikon: Dynamically Discovering Likely Program Invariants. Note: Just read the slides.</li> <li>Nguyen et al., SymInfer: Inferring Program Invariants using Symbolic States. ASE 2017. Note: Just read the slides.</li> <li>OPTIONAL Garg et al., Learning invariants using decision trees and implication counterexamples. POPL 2016.</li> </ol> <p>Tool: Daikon, SymInfer</p> <p>Optional: http://se.inf.ethz.ch/old/teaching/2009-S/0276/slides/schwab.pdf</p>"},{"location":"previous/reading19/#topic-6-program-synthesis-and-repair","title":"Topic 6: Program Synthesis and Repair","text":"<ol> <li>Weimer et al., Automatically finding patches using genetic programming. ICSE 2009</li> <li>Nguyen et al., Connecting Program Synthesis and Reachability: Automatic Program Repair using Test-Input Generation. TACAS 2017.</li> <li>Gulwani et al., Program Synthesis, CSUR, Chapters 1 and 2</li> <li>Gulwani et al., Program Synthesis, CSUR, Chapters 3 and 4</li> </ol> <p>Optional: Facebook's automatic bug fixing</p> <p>Tool: Sketch</p>"},{"location":"previous/reading19/#topic-7-logicssat-solving","title":"Topic 7: Logics/SAT Solving","text":"<ul> <li>Propositional calculus</li> <li>Conflict Driven Clause Learning</li> <li>First-Order Logic</li> <li>SMT Solver</li> </ul> <p>Optional: Shankar, Speaking Logic Tool: Z3</p>"},{"location":"previous/reading19/#topic-8-type-systems","title":"Topic 8: Type Systems","text":"<ol> <li>Luca Cardelli, Type Systems, CSUR 1996</li> </ol>"},{"location":"previous/reading19/#topic-9-automated-debugging","title":"Topic 9: Automated Debugging","text":"<ol> <li>James A. Jones et al., Visualization of test information to assist fault localization. ICSE 2002.</li> <li>Bessey et al., A Few Billion Lines of Code Later: Using Static Analysis to Find Bugs in the Real World. CACM</li> </ol> <p>Optional:  1. Andreas Zeller, Yesterday, My Program Worked. Today, It Does Not. Why?. FSE 1999. 1. Le et al., Compiler Validation via Equivalence Modulo Inputs , PLDI 2014,</p> <p>Tool: delta debugging</p>"},{"location":"previous/reading19/#additional-resources","title":"Additional Resources:","text":"<ul> <li>Basic stuff: control flow graph, live/reach defs: https://www.cs.odu.edu/~zeil/cs350/f18/Public/analysis/index.html</li> <li>Build System: https://www.cs.odu.edu/~zeil/cs350/f18/Public/make/index.html</li> <li>Call graphs etc: http://web.cs.iastate.edu/~weile/cs513x/4.ControlFlowAnalysis.pdf</li> <li>Dependency Graph/Slicing: http://web.cs.iastate.edu/~weile/cs513x/5.DependencySlicing.pdf</li> </ul>"},{"location":"previous/S20/","title":"General Info","text":"<p>Info</p> <pre><code>Meetings: TR 2:00PM - 3:15PM,  ZOOM\nInstructor: ThanhVu Nguyen\nEmail: tnguyen@unl.edu\nOffice Hours: After class\n</code></pre>"},{"location":"previous/S20/#description","title":"Description","text":"<p>This special topics course is a research seminar in software verification and analysis. The course covers active research areas in program analyses, but the specific topics will be largely determined by a combination of instructor fiat and the interests of the students.  We will also focus on the applications of these techniques, i.e., their uses in emergining computing domains such as Machine Learning, IoT, and Robotics.</p>"},{"location":"previous/S20/#grading","title":"Grading","text":"<p>You will be evaluated based on discussion and writting summaries on reading assignments and completing a final project.</p>"},{"location":"previous/S20/#reading","title":"Reading","text":"<p>We will read papers covering various topics including model checking, symbolic and concolic executions, constraint solving (e.g., SMT solvers), interactive theorem proving, automatic debugging, invariant generation (dynamic vs static analyses), automatic program repair, program synthesis (e.g., syntax-guided synthesis). We will also read papers that apply these techniques in practice (e.g., testing and verifying a Deep Neural Network or infering properties of an IoT system).</p>"},{"location":"previous/S20/#project","title":"Project","text":"<p>All students are expected to select and complete a project that explores more deeply a topic covered in the course (or a related topic which we didn't cover).</p> <p>The main goal of the project is for you to learn and understand topic in depth. The goal is not to force you all to produce novel results in one semester. Course projects like this often lead to collaborations that eventually yield exciting research. In the hopefully-likely event that you end up enjoying your project, come see me about taking it further (say, to publication).</p>"},{"location":"previous/S20/#course-policy","title":"Course Policy","text":"<ul> <li> <p>It is CSE Department policy that all students in CSE courses are   expected to regularly check their email so they do not miss   important announcements.</p> </li> <li> <p>All homework assignments, quizzes, exams, etc. must be your own   work. No direct collaboration with fellow students, past or current,   is allowed unless otherwise stated. The Computer Science &amp;   Engineering department has an Academic Integrity   Policy. All students   enrolled in any computer science course are bound by this policy.   You are expected to read, understand, and follow this policy.   Violations will be dealt with on a case by case basis and may result   in a failing assignment or a failing grade for the course itself.</p> </li> <li> <p>The CSE Department has an anonymous contact   form that you may use to voice   your concerns about any problems in the course or department if you   do not wish to be identified.</p> </li> <li> <p>Consider the Student Resource Center in   Avery 12 for additional help (e.g., TA's, tutorings, etc)</p> </li> <li> <p>Students with disabilities are encouraged to contact the instructor   for a confidential discussion of their individual needs for academic   accommodation. It is the policy of the University of   Nebraska-Lincoln to provide flexible and individualized   accommodations to students with documented disabilities that may   affect their ability to fully participate in course activities or to   meet course requirements. To receive accommodation services,   students must be registered with the Services for Students with   Disabilities (SSD) office, 132 Canfield Administration, 472-3787   voice or TTY.</p> </li> </ul>"},{"location":"previous/S20/#acknowledgements","title":"Acknowledgements","text":"<p>Thanks Westley Weimer for letting me reuse and adapt course materials from his graduate PL seminar courses.</p>"},{"location":"previous/S20/assignments/","title":"Reading","text":""},{"location":"previous/S20/assignments/#instructions","title":"Instructions","text":"<p>On average, we will discuss three papers a week (~50 minutes to each paper).  You are responsible for reading at least two papers in advance for any given discussion.</p> <p>At the beginning of each paper discussion I will choose up to three students at random.  Each student will give a five-minute presentation about the paper. </p> <p>This presentation must include:</p> <ul> <li>the problem (what is it? why is it interesting?)</li> <li>existing approaches (what are they? what are their limitations?)</li> <li>the proposed technical approach (also talk about the strengths of approach and how the approach addresses the weaknesses of existing works)</li> <li>limitations of the proposed approach and lists ways in which it might be improved.</li> </ul> <p>You can also include other information, such as your opinion about the work, or its relation to other work you may know. The goals of this approach are to encourage all participants to read the material thoroughly in advance, to provide jumping-off points for detailed discussions, and to allow me to evaluate participation.</p> <p>In addition, these chosen students will help engage discussions about the paper.</p>"},{"location":"previous/S20/assignments/#reading-list","title":"Reading List","text":""},{"location":"previous/S20/assignments/#background-program-analysis","title":"Background: Program Analysis","text":"<ul> <li>Software Testing using Fuzzing<ul> <li>Fuzzing: Hack, Art, and Science</li> <li>Evaluating Fuzz Testing</li> </ul> </li> <li>Model Checking<ul> <li>Model Checking: Algorithmic Verification and Debugging</li> </ul> </li> </ul> <ul> <li> <p>Miscs:   </p> <ul> <li>A Gentle Introduction to Program Analysis</li> </ul> </li> </ul>"},{"location":"previous/S20/assignments/#domain-1-iot-systems","title":"Domain 1: IoT systems","text":"<ol> <li>Scalable analysis of interaction threats in IoT systems. ISSTA 2020</li> <li>Understanding and Automatically Detecting Conflicting Interactions between Smart Home IoT Applications. FSE 2020</li> <li>Trace2TAP: Synthesizing Trigger-Action Programs From Traces of Behavior </li> <li>Charting the Attack Surface of Trigger-Action IoT Platforms.</li> <li>Decentralized Action Integrity for Trigger-Action IoT Platforms.</li> </ol>"},{"location":"previous/S20/assignments/#domain-2-deep-neural-networks","title":"Domain 2: Deep Neural Networks","text":"<ul> <li>Youtube Video: Verification of ML Programs, Guy Katz<ul> <li>pdf</li> </ul> </li> <li>Towards Verified Artificial Intelligence, Seshia et al.  </li> <li>Algorithms for Verifying Deep Neural Networks, Lieu et al.  SECTIONS 1-3 </li> <li>Algorithms for Verifying Deep Neural Networks, Lieu et al.  SECTIONS 4-5</li> <li>Algorithms for Verifying Deep Neural Networks, Lieu et al.  SECTIONS 4-5</li> <li>Reluplex: An Efficient SMT Solver for Verifying Deep Neural Networks</li> <li>The Marabou Framework for Verification and Analysis of Deep Neural Networks NEXT CLASS</li> <li>AI2: Safety and Robustness Certification of Neural Networks with Abstract Interpretation</li> <li>Reluval: Formal security analysis of neural networks using symbolic intervals</li> <li>NNV: The Neural Network Verification Tool for Deep Neural Networks and Learning-Enabled Cyber-Physical Systems</li> <li>General Lectures<ul> <li>AI^2: AI Safety and Robustness with Abstract Interpretation</li> <li>Lots of good talks/slides: https://mlcertifiedsystems.deel.ai/#Intro</li> </ul> </li> </ul>"},{"location":"previous/S20/assignments/#domain-3-networking","title":"Domain 3: Networking","text":"<ol> <li>Applying Formal Methods to Networking: Theory, Techniques, and Applications</li> <li>A Formally Verified NAT </li> <li>Model-Agnostic and Efficient Exploration of Numerical State Space of Real-World TCP Congestion Control Implementations. NSDI 2019</li> <li>Automated Verification of Customizable Middlebox Properties with Gravel</li> </ol>"},{"location":"previous/S20/project/","title":"Project Guideline","text":""},{"location":"previous/S20/project/#instructions","title":"Instructions","text":"<p>Your project will consist of two parts (i) a survey of the work in some area related to program verification and (ii) a research part that involves creating something new.</p>"},{"location":"previous/S20/project/#survey","title":"Survey","text":"<p>In this part, you will pick an area and a problem that you are interested in. Read at least three papers thoroughly and at least three other papers \"superficially\". I can provide some paper suggestions but you should do most of the work in tracking the relevant papers.</p> <p>Write about what you have learned. It should answer the questions:</p> <ul> <li>What are the basic problems?</li> <li>What are the basic approaches to solving them?</li> <li>What are the main achievements to date?</li> <li>What are the open problems?</li> <li>What further research or experiments do you propose in this area? Why?</li> </ul> <p>Keep the scope narrow enough so that you can learn something well and write something interesting.</p>"},{"location":"previous/S20/project/#implementation","title":"Implementation","text":"<p>In this part, you will propose and work on technique to solve the problem you picked. The technique can be either a new one or an improved/extended version of an existing one. This part is more time-consuming because it requires some implementation and experimentation. You can use any language (e.g., C/C++, Java, Python) for your implementation.</p>"},{"location":"previous/S20/project/#what-to-submit","title":"What to submit","text":""},{"location":"previous/S20/project/#project-proposal","title":"Project Proposal","text":"<p>By the end of the 4th week, submit a project proposal (one to two pages). The proposal should explain what you expect to learn from the project (i.e., why is it interesting to you?) and should include a work schedule. Make sure to budget time for writing a short project paper (5 pages) describing the project and/or for preparing a short (10 minute) project presentation during the last week of classes. The purpose of the proposal is for me to give you feedback on its feasibility.</p> <p>Scale of the project: 20--30 hrs should suffice (so if you actually put in about 2 hours a week, you would end up with pretty good project). But don't attempt to do everything in \"one long weekend\", it will not work.</p> <p>You are welcome to tackle a more ambitious project. Such a project should have \"stages\" so that you have something to show at the end of the semester. I (or your advisor) can provide extra guidance on such projects.</p> <p>If you have a great idea and need help, feel free to work as a pair. However, given the scope of most projects, I think they are better done alone. Notably, the grading for a two-person project will actually require \"twice as much work\" rather than the standard \"1.5-times as much work\".</p>"},{"location":"previous/S20/project/#project-report","title":"Project Report","text":"<p>You will write your project report as if you were submitting to a conference such as PLDI or ICSE (e.g., using LaTex templates for these conferences). Turn in the complete 5-page PDF as well as your LaTeX source.</p>"},{"location":"previous/S20/project/#status-update","title":"Status Update","text":"<p>The Status Update is a short email (less than a page) that explains what you have done so far and what you plan to do next.. It is due at the end of every month after your proposal is approved. This allows me to help if you are stuck.</p>"},{"location":"previous/S20/project/#presentation","title":"Presentation","text":"<p>You will give a short presentation of your project (10 minutes total for the presentation, and 3 for questions) and should describe what the problem was, what the difficulties were and what was accomplished or learned. You will find it much easier to prepare the talk using slides (6 to 8 slides excluding the title, depending on your speed).</p> <p>While preparing the talk keep in mind who your audience is. You will be presenting to colleagues who are eager to find out (1) about new exciting facets of programming languages and (2) how much fun you had. Plan to motivate the project (i.e., why is this important?) and to describe what you learned from it. Keep in mind that your colleagues have not read all the papers that you have read to do the project.</p>"},{"location":"previous/S20/project/#project-ideas","title":"Project Ideas","text":"<p>I encourage you to define your own project (you can also use your current research project with your own advisor, as long as it involves program analysis). In case you do not have any ideas, talk to me.</p>"}]}